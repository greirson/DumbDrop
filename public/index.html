<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{SITE_TITLE}} - Simple File Upload</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/toastify-js/src/toastify.min.css">
    <script src="https://cdn.jsdelivr.net/npm/toastify-js"></script>
</head>
<body>
    <div class="container">
        <button class="theme-toggle" onclick="toggleTheme()" aria-label="Toggle dark mode">
            <svg xmlns="http://www.w3.org/2000/svg" class="theme-toggle-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <!-- Moon icon (shown in light mode) -->
                <path class="moon" d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>
                <!-- Sun icon (shown in dark mode) -->
                <circle class="sun" cx="12" cy="12" r="5" style="display:none"/>
                <line class="sun" x1="12" y1="1" x2="12" y2="3" style="display:none"/>
                <line class="sun" x1="12" y1="21" x2="12" y2="23" style="display:none"/>
                <line class="sun" x1="4.22" y1="4.22" x2="5.64" y2="5.64" style="display:none"/>
                <line class="sun" x1="18.36" y1="18.36" x2="19.78" y2="19.78" style="display:none"/>
                <line class="sun" x1="1" y1="12" x2="3" y2="12" style="display:none"/>
                <line class="sun" x1="21" y1="12" x2="23" y2="12" style="display:none"/>
                <line class="sun" x1="4.22" y1="19.78" x2="5.64" y2="18.36" style="display:none"/>
                <line class="sun" x1="18.36" y1="5.64" x2="19.78" y2="4.22" style="display:none"/>
            </svg>
        </button>
        <h1>{{SITE_TITLE}}</h1>
        <div class="upload-container" id="dropZone">
            <div class="upload-content">
                <svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="17 8 12 3 7 8"/>
                    <line x1="12" y1="3" x2="12" y2="15"/>
                </svg>
                <p>Drag and drop files or folders here<br>or</p>
                <input type="file" id="fileInput" multiple hidden>
                <input type="file" id="folderInput" webkitdirectory directory multiple hidden>
                <div class="button-group">
                    <button onclick="document.getElementById('fileInput').click()">Browse Files</button>
                    <button onclick="document.getElementById('folderInput').click()">Browse Folders</button>
                </div>
            </div>
        </div>
        <div id="uploadProgress"></div>
        <div id="fileList" class="file-list"></div>
        <button id="uploadButton" class="upload-button" style="display: none;">Upload Files</button>
    </div>

    <style>
        .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
    </style>

    <script>
        const CHUNK_SIZE = 5 * 1024 * 1024; // 5MB chunks
        const MAX_RETRIES = 3;
        const RETRY_DELAY = 1000;

        class FileUploader {
            constructor(file) {
                this.file = file;
                this.uploadId = null;
                this.position = 0;
                this.progressElement = null;
                this.retries = 0;
                this.uploadTimeout = 30000;
                this.lastProgressTime = Date.now();
                this.concurrentChunks = navigator.hardwareConcurrency 
                    ? Math.min(navigator.hardwareConcurrency - 1, 4) // Use CPU cores - 1, max 4
                    : 3;
                this.activeUploads = 0;
                this.chunkQueue = [];
                this.failed = false;
                this.bytesUploaded = 0;
                this.lastUpdate = Date.now();
                this.lastBytes = 0;
                this.speedHistory = [];
                this.lastSpeedUpdate = Date.now();
                this.chunkSize = this.calculateOptimalChunkSize(file.size);
                this.paused = false;
            }

            calculateOptimalChunkSize(fileSize) {
                // For small files, use smaller chunks
                if (fileSize < 50 * 1024 * 1024) { // < 50MB
                    return 1 * 1024 * 1024; // 1MB chunks
                }
                // For medium files
                if (fileSize < 1024 * 1024 * 1024) { // < 1GB
                    return 5 * 1024 * 1024; // 5MB chunks
                }
                // For large files
                return 10 * 1024 * 1024; // 10MB chunks
            }

            async start() {
                try {
                    await this.initUpload();
                    await this.uploadChunks();
                    return true;
                } catch (error) {
                    console.error('Upload failed:', error);
                    return false;
                }
            }

            async initUpload() {
                const uploadPath = this.file.relativePath ? 
                    `${this.file.relativePath}${this.file.name}` : 
                    this.file.name;

                const response = await fetch('/upload/init', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        filename: uploadPath,
                        fileSize: this.file.size
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    if (response.status === 413) {
                        throw new Error(`File too large. Maximum size is ${error.limitInMB}MB`);
                    }
                    throw new Error('Failed to initialize upload');
                }
                const data = await response.json();
                this.uploadId = data.uploadId;
            }

            async uploadChunks() {
                this.createProgressElement();
                this.bytesUploaded = 0;
                
                // Use async generator for memory-efficient chunk creation
                for await (const chunk of this.generateChunks()) {
                    this.chunkQueue.push({
                        chunk,
                        position: this.position - chunk.byteLength
                    });

                    // Process chunks when queue gets too large
                    if (this.chunkQueue.length >= this.concurrentChunks * 2) {
                        await this.processChunkQueue();
                    }
                }

                // Process remaining chunks
                await this.processChunkQueue();
            }

            async *generateChunks() {
                while (this.position < this.file.size) {
                    const chunk = await this.readChunk();
                    yield chunk;
                }
            }

            async processChunkQueue() {
                if (this.failed) return;
                
                // Create a pool of promises for concurrent uploads
                while (this.chunkQueue.length > 0 && !this.failed && !this.paused) {
                    const uploadPromises = [];
                    
                    // Fill the upload pool up to concurrentChunks
                    while (this.activeUploads < this.concurrentChunks && this.chunkQueue.length > 0) {
                        const chunkInfo = this.chunkQueue.shift();
                        this.activeUploads++;
                        
                        const uploadPromise = (async () => {
                            try {
                                await this.uploadChunk(chunkInfo.chunk);
                                this.bytesUploaded += chunkInfo.chunk.byteLength;
                                const progress = Math.round((this.bytesUploaded / this.file.size) * 100);
                                // Use requestAnimationFrame for smoother UI updates
                                requestAnimationFrame(() => this.updateProgress(progress));
                            } catch (error) {
                                if (error.message === 'Rate limited - retrying') {
                                    // For rate limiting, add chunk back to queue
                                    this.chunkQueue.unshift(chunkInfo);
                                } else {
                                    console.error('Chunk upload error:', error);
                                    this.failed = true;
                                    throw error;
                                }
                            } finally {
                                this.activeUploads--;
                            }
                        })();
                        
                        uploadPromises.push(uploadPromise);
                    }
                    
                    // Wait for any upload to complete before continuing
                    if (uploadPromises.length > 0) {
                        try {
                            await Promise.race(uploadPromises);
                        } catch (error) {
                            if (this.failed) break;
                        }
                    }
                    
                    // Small delay to prevent UI blocking
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
            }

            async readChunk() {
                const start = this.position;
                const end = Math.min(this.position + this.chunkSize, this.file.size);
                const blob = this.file.slice(start, end);
                this.position = end;
                return await blob.arrayBuffer();
            }

            async uploadChunk(chunk) {
                let attempt = 0;
                const maxAttempts = 3;
                
                while (attempt < maxAttempts) {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), this.uploadTimeout);

                    try {
                        const response = await fetch(`/upload/chunk/${this.uploadId}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/octet-stream'
                            },
                            body: chunk,
                            signal: controller.signal
                        });

                        clearTimeout(timeoutId);

                        if (!response.ok) {
                            if (response.status === 429) {
                                const retryAfter = response.headers.get('Retry-After');
                                const delayMs = (retryAfter ? parseInt(retryAfter) : 5) * 1000;
                                await new Promise(resolve => setTimeout(resolve, delayMs));
                                throw new Error('Rate limited - retrying');
                            }

                            throw new Error(await response.text());
                        }

                        return await response.json();
                    } catch (error) {
                        clearTimeout(timeoutId);
                        
                        if (error.name === 'AbortError') {
                            error.message = 'Request timed out';
                        }
                        
                        attempt++;
                        if (error.message === 'Rate limited - retrying' || attempt >= maxAttempts) {
                            throw error;
                        }
                        
                        // Exponential backoff
                        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
                    }
                }
            }

            createProgressElement() {
                const container = document.createElement('div');
                container.className = 'progress-container';
                
                const label = document.createElement('div');
                label.className = 'progress-label';
                const displayPath = this.file.relativePath ? 
                    `üìÅ ${this.file.relativePath.split('/')[0]}/` : 
                    `üìÑ ${this.file.name}`;
                label.textContent = displayPath;

                const progress = document.createElement('div');
                progress.className = 'progress';
                
                const bar = document.createElement('div');
                bar.className = 'progress-bar';
                bar.style.width = '0%';

                const stats = document.createElement('div');
                stats.className = 'progress-stats';
                stats.innerHTML = `
                    <span class="progress-percentage">0%</span>
                    <span class="progress-speed">0 MB/s</span>
                    <span class="progress-time">Calculating...</span>
                `;

                progress.appendChild(bar);
                container.appendChild(label);
                container.appendChild(progress);
                container.appendChild(stats);
                
                document.getElementById('uploadProgress').appendChild(container);
                this.progressElement = { 
                    container, 
                    bar,
                    percentage: stats.querySelector('.progress-percentage'),
                    speed: stats.querySelector('.progress-speed'),
                    time: stats.querySelector('.progress-time')
                };
            }

            updateProgress(percent) {
                if (!this.progressElement) return;

                const now = Date.now();
                
                // Throttle speed calculations to every 500ms
                if (now - this.lastSpeedUpdate >= 500) {
                    const timeDiff = (now - this.lastUpdate) / 1000;
                    const bytesDiff = this.bytesUploaded - this.lastBytes;
                    
                    // Only calculate speed if we have meaningful data
                    if (timeDiff > 0.1 && bytesDiff > 0) {
                        const currentSpeed = bytesDiff / timeDiff;
                        
                        // Filter out unreasonable speeds
                        if (currentSpeed > 0 && currentSpeed < (this.file.size / 2)) {
                            this.speedHistory.push(currentSpeed);
                            if (this.speedHistory.length > 5) {
                                this.speedHistory.shift();
                            }
                        }
                    }
                    
                    this.lastUpdate = now;
                    this.lastBytes = this.bytesUploaded;
                    this.lastSpeedUpdate = now;
                }
                
                // Calculate average speed using the median for more stability
                const avgSpeed = this.calculateMedianSpeed();
                
                // Calculate time remaining
                const remainingBytes = this.file.size - this.bytesUploaded;
                const timeRemaining = avgSpeed > 0 ? remainingBytes / avgSpeed : 0;
                
                // Update UI elements
                requestAnimationFrame(() => {
                    this.progressElement.bar.style.width = `${percent}%`;
                    this.progressElement.percentage.textContent = `${percent}%`;
                    this.progressElement.speed.textContent = formatSpeed(avgSpeed);
                    this.progressElement.time.textContent = formatTimeRemaining(timeRemaining);
                });

                if (percent === 100) {
                    setTimeout(() => {
                        this.progressElement.container.remove();
                    }, 1000);
                }
            }

            calculateMedianSpeed() {
                if (this.speedHistory.length === 0) return 0;
                
                const sorted = [...this.speedHistory].sort((a, b) => a - b);
                const middle = Math.floor(sorted.length / 2);
                
                if (sorted.length % 2 === 0) {
                    return (sorted[middle - 1] + sorted[middle]) / 2;
                }
                return sorted[middle];
            }

            pause() {
                this.paused = true;
                if (this.progressElement) {
                    this.progressElement.time.textContent = 'Paused';
                }
            }

            resume() {
                this.paused = false;
                this.processChunkQueue();
            }
        }

        // UI Event Handlers
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const folderInput = document.getElementById('folderInput');
        const fileList = document.getElementById('fileList');
        const uploadButton = document.getElementById('uploadButton');
        let files = [];

        // Helper function to group files by folder
        function groupFilesByFolder(fileList) {
            const groups = new Map();
            
            fileList.forEach(file => {
                const path = file.webkitRelativePath || file.relativePath + file.name;
                const parts = path.split('/');
                
                if (parts.length > 1) {
                    // This is a file in a folder
                    const folderName = parts[0];
                    if (!groups.has(folderName)) {
                        groups.set(folderName, {
                            name: folderName,
                            isFolder: true,
                            totalSize: 0,
                            files: []
                        });
                    }
                    const group = groups.get(folderName);
                    group.files.push(file);
                    group.totalSize += file.size;
                } else {
                    // This is a root-level file
                    groups.set(file.name, {
                        name: file.name,
                        isFolder: false,
                        totalSize: file.size,
                        files: [file]
                    });
                }
            });
            
            return Array.from(groups.values());
        }

        // Helper function to process directory entries
        async function getAllFileEntries(dataTransferItems) {
            let fileEntries = [];
            
            async function traverseEntry(entry, path = '') {
                if (entry.isFile) {
                    const file = await new Promise((resolve) => entry.file(resolve));
                    file.relativePath = path;
                    fileEntries.push(file);
                } else if (entry.isDirectory) {
                    const reader = entry.createReader();
                    const entries = await new Promise((resolve) => {
                        reader.readEntries(resolve);
                    });
                    
                    for (const childEntry of entries) {
                        await traverseEntry(childEntry, path + entry.name + '/');
                    }
                }
            }

            const items = [...dataTransferItems];
            for (const item of items) {
                const entry = item.webkitGetAsEntry();
                if (entry) {
                    await traverseEntry(entry);
                }
            }

            return fileEntries;
        }

        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
            document.body.addEventListener(eventName, preventDefaults, false);
        });

        ['dragenter', 'dragover'].forEach(eventName => {
            dropZone.addEventListener(eventName, highlight, false);
        });

        ['dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, unhighlight, false);
        });

        dropZone.addEventListener('drop', handleDrop, false);
        fileInput.addEventListener('change', handleFiles, false);
        folderInput.addEventListener('change', handleFolders, false);
        uploadButton.addEventListener('click', startUploads);

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function highlight(e) {
            dropZone.classList.add('highlight');
        }

        function unhighlight(e) {
            dropZone.classList.remove('highlight');
        }

        function handleDrop(e) {
            const items = e.dataTransfer.items;
            if (items && items[0].webkitGetAsEntry) {
                getAllFileEntries(items).then(newFiles => {
                    files = newFiles;
                    updateFileList();
                });
            } else {
                files = [...e.dataTransfer.files];
                updateFileList();
            }
        }

        function handleFiles(e) {
            files = [...e.target.files];
            files.forEach(file => {
                file.relativePath = ''; // No relative path for individual files
            });
            updateFileList();
        }

        function handleFolders(e) {
            files = [...e.target.files];
            files.forEach(file => {
                const pathParts = file.webkitRelativePath.split('/');
                pathParts.pop(); // Remove filename
                file.relativePath = pathParts.length > 0 ? pathParts.join('/') + '/' : '';
            });
            updateFileList();
        }

        function updateFileList() {
            fileList.innerHTML = '';
            const groupedItems = groupFilesByFolder(files);
            
            groupedItems.forEach(item => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                
                if (item.isFolder) {
                    fileItem.innerHTML = `üìÅ ${item.name}/ (${formatFileSize(item.totalSize)} - ${item.files.length} files)`;
                } else {
                    fileItem.innerHTML = `üìÑ ${item.name} (${formatFileSize(item.totalSize)})`;
                }
                
                fileList.appendChild(fileItem);
            });
            
            uploadButton.style.display = files.length > 0 ? 'block' : 'none';
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        async function startUploads() {
            uploadButton.disabled = true;
            document.getElementById('uploadProgress').innerHTML = '';
            
            let successCount = 0;
            let failCount = 0;
            
            for (const item of groupFilesByFolder(files)) {
                for (const file of item.files) {
                    try {
                        const uploader = new FileUploader(file);
                        await uploader.start();
                        successCount++;
                    } catch (error) {
                        console.error(`Failed to upload ${file.name}:`, error);
                        failCount++;
                        
                        // Continue with other files even if one fails
                        continue;
                    }
                }
            }

            // Show final status
            Toastify({
                text: `Uploaded ${successCount} files${failCount > 0 ? `, ${failCount} failed` : ''}`,
                duration: 3000,
                gravity: "bottom",
                position: "right",
                style: {
                    background: failCount === 0 ? "#4CAF50" : "#f44336"
                }
            }).showToast();

            files = [];
            updateFileList();
            uploadButton.disabled = false;
        }

        // Theme management
        function setTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
            
            // Update icon
            const moonPaths = document.querySelectorAll('.moon');
            const sunPaths = document.querySelectorAll('.sun');
            
            if (theme === 'dark') {
                moonPaths.forEach(path => path.style.display = 'none');
                sunPaths.forEach(path => path.style.display = '');
            } else {
                moonPaths.forEach(path => path.style.display = '');
                sunPaths.forEach(path => path.style.display = 'none');
            }
        }

        function toggleTheme() {
            const current = document.documentElement.getAttribute('data-theme');
            const next = current === 'dark' ? 'light' : 'dark';
            setTheme(next);
        }

        // Initialize theme
        const savedTheme = localStorage.getItem('theme') || 
            (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
        setTheme(savedTheme);

        function formatSpeed(bytesPerSecond) {
            if (!bytesPerSecond || bytesPerSecond === 0) return '0 B/s';
            if (!isFinite(bytesPerSecond)) return 'Calculating...';
            
            const units = ['B/s', 'KB/s', 'MB/s', 'GB/s'];
            let speed = bytesPerSecond;
            let unitIndex = 0;
            
            while (speed >= 1024 && unitIndex < units.length - 1) {
                speed /= 1024;
                unitIndex++;
            }
            
            // Limit to reasonable values
            if (speed > 1000000) return 'Calculating...';
            
            return `${speed.toFixed(1)} ${units[unitIndex]}`;
        }

        function formatTimeRemaining(seconds) {
            if (!isFinite(seconds) || seconds === 0) return 'Calculating...';
            if (seconds < 1) return 'Almost done...';
            
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            
            if (hours > 0) {
                return `${hours}h ${minutes}m remaining`;
            } else if (minutes > 0) {
                return `${minutes}m ${secs}s remaining`;
            } else {
                return `${secs}s remaining`;
            }
        }

        window.addEventListener('beforeunload', async (event) => {
            // Cancel any ongoing uploads
            const uploadProgress = document.getElementById('uploadProgress');
            if (uploadProgress.children.length > 0) {
                event.preventDefault();
                event.returnValue = '';
                
                // Attempt to cancel uploads gracefully
                const cancelPromises = Array.from(uploadProgress.children).map(async (container) => {
                    const uploadId = container.dataset.uploadId;
                    if (uploadId) {
                        try {
                            await fetch(`/upload/cancel/${uploadId}`, { method: 'POST' });
                        } catch (error) {
                            console.error('Failed to cancel upload:', error);
                        }
                    }
                });
                
                await Promise.all(cancelPromises);
            }
        });
    </script>
</body>
</html>
